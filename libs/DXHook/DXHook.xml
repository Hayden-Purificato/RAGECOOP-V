<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DXHook</name>
    </assembly>
    <members>
        <member name="F:DXHook.CaptureProcess._channelName">
            <summary>
            Must be null to allow a random channel name to be generated
            </summary>
        </member>
        <member name="M:DXHook.CaptureProcess.#ctor(System.Diagnostics.Process,DXHook.Interface.CaptureConfig,DXHook.Interface.CaptureInterface)">
            <summary>
            Prepares capturing in the target process. Note that the process must not already be hooked, and must have a <see cref="P:System.Diagnostics.Process.MainWindowHandle"/>.
            </summary>
            <param name="process">The process to inject into</param>
            <exception cref="T:DXHook.ProcessHasNoWindowHandleException">Thrown if the <paramref name="process"/> does not have a window handle. This could mean that the process does not have a UI, or that the process has not yet finished starting.</exception>
            <exception cref="T:DXHook.ProcessAlreadyHookedException">Thrown if the <paramref name="process"/> is already hooked</exception>
            <exception cref="T:DXHook.InjectionFailedException">Thrown if the injection failed - see the InnerException for more details.</exception>
            <remarks>The target process will have its main window brought to the foreground after successful injection.</remarks>
        </member>
        <member name="M:DXHook.CaptureProcess.BringProcessWindowToFront">
            <summary>
            Bring the target window to the front and wait for it to be visible
            </summary>
            <remarks>If the window does not come to the front within approx. 30 seconds an exception is raised</remarks>
        </member>
        <member name="M:DXHook.EntryPoint.StartCheckHostIsAliveThread">
            <summary>
            Begin a background thread to check periodically that the host process is still accessible on its IPC channel
            </summary>
        </member>
        <member name="M:DXHook.EntryPoint.StopCheckHostIsAliveThread">
            <summary>
            Tell the _checkAlive thread that it can exit if it hasn't already
            </summary>
        </member>
        <member name="T:DXHook.ProcessHasNoWindowHandleException">
            <summary>
            Indicates that the provided process does not have a window handle.
            </summary>
        </member>
        <member name="P:DXHook.Hook.BaseDXHook.FPS">
            <summary>
            Frames Per second counter, FPS.Frame() must be called each frame
            </summary>
        </member>
        <member name="M:DXHook.Hook.BaseDXHook.ReadFullStream(System.IO.Stream)">
            <summary>
            Reads data from a stream until the end is reached. The
            data is returned as a byte array. An IOException is
            thrown if any of the underlying IO calls fail.
            </summary>
            <param name="stream">The stream to read data from</param>
        </member>
        <member name="M:DXHook.Hook.BaseDXHook.ProcessCapture(System.Int32,System.Int32,System.Int32,System.Drawing.Imaging.PixelFormat,System.IntPtr,DXHook.Interface.ScreenshotRequest)">
            <summary>
            Process the capture based on the requested format.
            </summary>
            <param name="width">image width</param>
            <param name="height">image height</param>
            <param name="pitch">data pitch (bytes per row)</param>
            <param name="format">target format</param>
            <param name="pBits">IntPtr to the image data</param>
            <param name="request">The original requets</param>
        </member>
        <member name="M:DXHook.Hook.Common.Element.Dispose(System.Boolean)">
            <summary>
            Releases unmanaged and optionally managed resources
            </summary>
            <param name="disposing">true if disposing both unmanaged and managed</param>
        </member>
        <member name="M:DXHook.Hook.Common.FramesPerSecond.Frame">
            <summary>
            Must be called each frame
            </summary>
        </member>
        <member name="M:DXHook.Hook.Common.FramesPerSecond.GetFPS">
            <summary>
            Return the current frames per second
            </summary>
            <returns></returns>
        </member>
        <member name="P:DXHook.Hook.Common.ImageElement.PtrBuffer">
            <summary>
            Pointer to this image's underlying buffer area
            </summary>
        </member>
        <member name="M:DXHook.Hook.Common.ImageElement.SetBitmap(System.Drawing.Bitmap)">
            <summary>
            Update current bitmap with supplied one
            </summary>
            <param name="bmp">The bitmap to replace current one with</param>
            <remarks>Image buffer is copied to <see cref="P:DXHook.Hook.Common.ImageElement.PtrBuffer"/></remarks>
        </member>
        <member name="P:DXHook.Hook.Common.ImageElement.Tint">
            <summary>
            This value is multiplied with the source color (e.g. White will result in same color as source image)
            </summary>
            <remarks>
            Defaults to <see cref="P:System.Drawing.Color.White"/>.
            </remarks>
        </member>
        <member name="P:DXHook.Hook.Common.ImageElement.Location">
            <summary>
            The location of where to render this image element
            </summary>
        </member>
        <member name="T:DXHook.Hook.Direct3DDevice9FunctionOrdinals">
            <summary>
            The full list of IDirect3DDevice9 functions with the correct index
            </summary>
        </member>
        <member name="P:DXHook.Hook.DX11.DeviceManager.Direct3DDevice">
            <summary>
            Gets the Direct3D11 device.
            </summary>
        </member>
        <member name="P:DXHook.Hook.DX11.DeviceManager.Direct3DContext">
            <summary>
            Gets the Direct3D11 immediate context.
            </summary>
        </member>
        <member name="M:DXHook.Hook.DX11.DXOverlayEngine.Draw">
            <summary>
            Draw the overlay(s)
            </summary>
        </member>
        <member name="M:DXHook.Hook.DX11.DXOverlayEngine.Dispose(System.Boolean)">
            <summary>
            Releases unmanaged and optionally managed resources
            </summary>
            <param name="disposing">true if disposing both unmanaged and managed</param>
        </member>
        <member name="M:DXHook.Hook.DX11.RendererBase.Initialize(DXHook.Hook.DX11.DeviceManager)">
            <summary>
            Initialize with the provided deviceManager
            </summary>
            <param name="deviceManager"></param>
        </member>
        <member name="M:DXHook.Hook.DX11.RendererBase.CreateDeviceDependentResources">
            <summary>
            Create any resources that depend on the device or device context
            </summary>
        </member>
        <member name="M:DXHook.Hook.DX11.RendererBase.CreateSizeDependentResources">
            <summary>
            Create any resources that depend upon the size of the render target
            </summary>
        </member>
        <member name="M:DXHook.Hook.DX11.RendererBase.Render">
            <summary>
            Render a frame
            </summary>
        </member>
        <member name="M:DXHook.Hook.DX11.RendererBase.DoRender">
            <summary>
            Each descendant of RendererBase performs a frame
            render within the implementation of DoRender
            </summary>
        </member>
        <member name="M:DXHook.Hook.DX11.ScreenAlignedQuadRenderer.CreateDeviceDependentResources">
            <summary>
            Create any device dependent resources here.
            This method will be called when the device is first
            initialized or recreated after being removed or reset.
            </summary>
        </member>
        <member name="M:DXHook.Hook.DX9.DXOverlayEngine.Draw">
            <summary>
            Draw the overlay(s)
            </summary>
        </member>
        <member name="M:DXHook.Hook.DX9.DXOverlayEngine.BeforeDeviceReset">
            <summary>
            In Direct3D9 it is necessary to call OnLostDevice before any call to device.Reset(...) for certain interfaces found in D3DX (e.g. ID3DXSprite, ID3DXFont, ID3DXLine) - https://msdn.microsoft.com/en-us/library/windows/desktop/bb172979(v=vs.85).aspx
            </summary>
        </member>
        <member name="M:DXHook.Hook.DX9.DXOverlayEngine.Dispose(System.Boolean)">
            <summary>
            Releases unmanaged and optionally managed resources
            </summary>
            <param name="disposing">true if disposing both unmanaged and managed</param>
        </member>
        <member name="T:DXHook.Hook.DXHookD3D10">
            <summary>
            Direct3D 10 Hook - this hooks the SwapChain.Present method to capture images
            </summary>
        </member>
        <member name="T:DXHook.Hook.DXHookD3D10.DXGISwapChain_PresentDelegate">
            <summary>
            The IDXGISwapChain.Present function definition
            </summary>
            <param name="device"></param>
            <returns></returns>
        </member>
        <member name="T:DXHook.Hook.DXHookD3D10.DXGISwapChain_ResizeTargetDelegate">
            <summary>
            The IDXGISwapChain.ResizeTarget function definition
            </summary>
            <param name="device"></param>
            <returns></returns>
        </member>
        <member name="M:DXHook.Hook.DXHookD3D10.ResizeTargetHook(System.IntPtr,SharpDX.DXGI.ModeDescription@)">
            <summary>
            Hooked to allow resizing a texture/surface that is reused. Currently not in use as we create the texture for each request
            to support different sizes each time (as we use DirectX to copy only the region we are after rather than the entire backbuffer)
            </summary>
            <param name="swapChainPtr"></param>
            <param name="newTargetParameters"></param>
            <returns></returns>
        </member>
        <member name="M:DXHook.Hook.DXHookD3D10.PresentHook(System.IntPtr,System.Int32,SharpDX.DXGI.PresentFlags)">
            <summary>
            Our present hook that will grab a copy of the backbuffer when requested. Note: this supports multi-sampling (anti-aliasing)
            </summary>
            <param name="swapChainPtr"></param>
            <param name="syncInterval"></param>
            <param name="flags"></param>
            <returns>The HRESULT of the original method</returns>
        </member>
        <member name="T:DXHook.Hook.DXHookD3D10_1">
            <summary>
            Direct3D 10.1 Hook - this hooks the SwapChain.Present method to capture images
            </summary>
        </member>
        <member name="T:DXHook.Hook.DXHookD3D10_1.DXGISwapChain_PresentDelegate">
            <summary>
            The IDXGISwapChain.Present function definition
            </summary>
            <param name="device"></param>
            <returns></returns>
        </member>
        <member name="T:DXHook.Hook.DXHookD3D10_1.DXGISwapChain_ResizeTargetDelegate">
            <summary>
            The IDXGISwapChain.ResizeTarget function definition
            </summary>
            <param name="device"></param>
            <returns></returns>
        </member>
        <member name="M:DXHook.Hook.DXHookD3D10_1.ResizeTargetHook(System.IntPtr,SharpDX.DXGI.ModeDescription@)">
            <summary>
            Hooked to allow resizing a texture/surface that is reused. Currently not in use as we create the texture for each request
            to support different sizes each time (as we use DirectX to copy only the region we are after rather than the entire backbuffer)
            </summary>
            <param name="swapChainPtr"></param>
            <param name="newTargetParameters"></param>
            <returns></returns>
        </member>
        <member name="M:DXHook.Hook.DXHookD3D10_1.PresentHook(System.IntPtr,System.Int32,SharpDX.DXGI.PresentFlags)">
            <summary>
            Our present hook that will grab a copy of the backbuffer when requested. Note: this supports multi-sampling (anti-aliasing)
            </summary>
            <param name="swapChainPtr"></param>
            <param name="syncInterval"></param>
            <param name="flags"></param>
            <returns>The HRESULT of the original method</returns>
        </member>
        <member name="T:DXHook.Hook.DXHookD3D11">
            <summary>
            Direct3D 11 Hook - this hooks the SwapChain.Present to take screenshots
            </summary>
        </member>
        <member name="T:DXHook.Hook.DXHookD3D11.DXGISwapChain_PresentDelegate">
            <summary>
            The IDXGISwapChain.Present function definition
            </summary>
            <param name="device"></param>
            <returns></returns>
        </member>
        <member name="T:DXHook.Hook.DXHookD3D11.DXGISwapChain_ResizeTargetDelegate">
            <summary>
            The IDXGISwapChain.ResizeTarget function definition
            </summary>
            <param name="device"></param>
            <returns></returns>
        </member>
        <member name="M:DXHook.Hook.DXHookD3D11.ResizeTargetHook(System.IntPtr,SharpDX.DXGI.ModeDescription@)">
            <summary>
            Hooked to allow resizing a texture/surface that is reused. Currently not in use as we create the texture for each request
            to support different sizes each time (as we use DirectX to copy only the region we are after rather than the entire backbuffer)
            </summary>
            <param name="swapChainPtr"></param>
            <param name="newTargetParameters"></param>
            <returns></returns>
        </member>
        <member name="M:DXHook.Hook.DXHookD3D11.PresentHook(System.IntPtr,System.Int32,SharpDX.DXGI.PresentFlags)">
            <summary>
            Our present hook that will grab a copy of the backbuffer when requested. Note: this supports multi-sampling (anti-aliasing)
            </summary>
            <param name="swapChainPtr"></param>
            <param name="syncInterval"></param>
            <param name="flags"></param>
            <returns>The HRESULT of the original method</returns>
        </member>
        <member name="M:DXHook.Hook.DXHookD3D11.ToStream(SharpDX.Direct3D11.DeviceContext,SharpDX.Direct3D11.Texture2D,DXHook.Interface.ImageFormat,System.IO.Stream)">
            <summary>
            Copies to a stream using WIC. The format is converted if necessary.
            </summary>
            <param name="context"></param>
            <param name="texture"></param>
            <param name="outputFormat"></param>
            <param name="stream"></param>
        </member>
        <member name="M:DXHook.Hook.DXHookD3D9.Cleanup">
            <summary>
            Just ensures that the surface we created is cleaned up.
            </summary>
        </member>
        <member name="T:DXHook.Hook.DXHookD3D9.Direct3D9Device_EndSceneDelegate">
            <summary>
            The IDirect3DDevice9.EndScene function definition
            </summary>
            <param name="device"></param>
            <returns></returns>
        </member>
        <member name="T:DXHook.Hook.DXHookD3D9.Direct3D9Device_ResetDelegate">
            <summary>
            The IDirect3DDevice9.Reset function definition
            </summary>
            <param name="device"></param>
            <param name="presentParameters"></param>
            <returns></returns>
        </member>
        <member name="M:DXHook.Hook.DXHookD3D9.ResetHook(System.IntPtr,SharpDX.Direct3D9.PresentParameters@)">
            <summary>
            Reset the _renderTarget so that we are sure it will have the correct presentation parameters (required to support working across changes to windowed/fullscreen or resolution changes)
            </summary>
            <param name="devicePtr"></param>
            <param name="presentParameters"></param>
            <returns></returns>
        </member>
        <member name="M:DXHook.Hook.DXHookD3D9.EndSceneHook(System.IntPtr)">
            <summary>
            Hook for IDirect3DDevice9.EndScene
            </summary>
            <param name="devicePtr">Pointer to the IDirect3DDevice9 instance. Note: object member functions always pass "this" as the first parameter.</param>
            <returns>The HRESULT of the original EndScene</returns>
            <remarks>Remember that this is called many times a second by the Direct3D application - be mindful of memory and performance!</remarks>
        </member>
        <member name="M:DXHook.Hook.DXHookD3D9.DoCaptureRenderTarget(SharpDX.Direct3D9.Device,System.String)">
            <summary>
            Implementation of capturing from the render target of the Direct3D9 Device (or DeviceEx)
            </summary>
            <param name="device"></param>
        </member>
        <member name="T:DXHook.Hook.FramesPerSecond">
            <summary>
            Used to determine the FPS
            </summary>
        </member>
        <member name="M:DXHook.Hook.FramesPerSecond.Frame">
            <summary>
            Must be called each frame
            </summary>
        </member>
        <member name="M:DXHook.Hook.FramesPerSecond.GetFPS">
            <summary>
            Return the current frames per second
            </summary>
            <returns></returns>
        </member>
        <member name="T:DXHook.Hook.Hook`1">
            <summary>
            Extends <see cref="T:DXHook.Hook.Hook"/> with support for accessing the Original method from within a hook delegate
            </summary>
            <typeparam name="T">A delegate type</typeparam>
        </member>
        <member name="P:DXHook.Hook.Hook`1.Original">
            <summary>
            When called from within the <see cref="P:DXHook.Hook.Hook.NewFunc"/> delegate this will call the original function at <see cref="P:DXHook.Hook.Hook.FuncToHook"/>.
            </summary>
        </member>
        <member name="M:DXHook.Hook.Hook`1.#ctor(System.IntPtr,System.Delegate,System.Object)">
            <summary>
            Creates a new hook at <paramref name="funcToHook"/> redirecting to <paramref name="newFunc"/>. The hook starts inactive so a call to <see cref="!:Activate"/> is required to enable the hook.
            </summary>
            <param name="funcToHook">A pointer to the location to insert the hook</param>
            <param name="newFunc">The delegate to call from the hooked location</param>
            <param name="owner">The object to assign as the "callback" object within the <see cref="T:EasyHook.LocalHook"/> instance.</param>
        </member>
        <member name="T:DXHook.Hook.Hook">
            <summary>
            Wraps the <see cref="T:EasyHook.LocalHook"/> class with a simplified active/inactive state
            </summary>
        </member>
        <member name="P:DXHook.Hook.Hook.FuncToHook">
            <summary>
            The hooked function location
            </summary>
        </member>
        <member name="P:DXHook.Hook.Hook.NewFunc">
            <summary>
            The replacement delegate
            </summary>
        </member>
        <member name="P:DXHook.Hook.Hook.Owner">
            <summary>
            The callback object passed to LocalHook constructor
            </summary>
        </member>
        <member name="P:DXHook.Hook.Hook.LocalHook">
            <summary>
            The <see cref="T:EasyHook.LocalHook"/> instance
            </summary>
        </member>
        <member name="P:DXHook.Hook.Hook.IsActive">
            <summary>
            Indicates whether the hook is currently active
            </summary>
        </member>
        <member name="M:DXHook.Hook.Hook.#ctor(System.IntPtr,System.Delegate,System.Object)">
            <summary>
            Creates a new hook at <paramref name="funcToHook"/> redirecting to <paramref name="newFunc"/>. The hook starts inactive so a call to <see cref="M:DXHook.Hook.Hook.Activate"/> is required to enable the hook.
            </summary>
            <param name="funcToHook">A pointer to the location to insert the hook</param>
            <param name="newFunc">The delegate to call from the hooked location</param>
            <param name="owner">The object to assign as the "callback" object within the <see cref="T:EasyHook.LocalHook"/> instance.</param>
        </member>
        <member name="M:DXHook.Hook.Hook.Activate">
            <summary>
            Activates the hook
            </summary>
        </member>
        <member name="M:DXHook.Hook.Hook.Deactivate">
            <summary>
            Deactivates the hook
            </summary>
        </member>
        <member name="T:DXHook.Hook.SafeHGlobal">
            <summary>
            Provides a safe handle around a block of unmanaged memory.
            </summary>
        </member>
        <member name="P:DXHook.Hook.SafeHGlobal.IsInvalid">
            <summary>
            When overridden in a derived class, gets a value indicating whether the handle value is invalid.
            </summary>
            <returns>true if the handle value is invalid; otherwise, false.</returns>
        </member>
        <member name="M:DXHook.Hook.SafeHGlobal.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:DXHook.Hook.SafeHGlobal"/> class.
            </summary>
            <param name="sizeInBytes">The size of the block of memory to allocate, in bytes.</param>
        </member>
        <member name="M:DXHook.Hook.SafeHGlobal.ReleaseHandle">
            <summary>
            When overridden in a derived class, executes the code required to free the handle.
            </summary>
            <returns>
            true if the handle is released successfully; otherwise, in the event of a catastrophic failure, false. In this case, it generates a releaseHandleFailed MDA Managed Debugging Assistant.
            </returns>
        </member>
        <member name="M:DXHook.Hook.TextDisplay.Frame">
            <summary>
            Must be called each frame
            </summary>
        </member>
        <member name="P:DXHook.Interface.CaptureInterface.ProcessId">
            <summary>
            The client process Id
            </summary>
        </member>
        <member name="E:DXHook.Interface.CaptureInterface.RemoteMessage">
            <summary>
            Server event for sending debug and error information from the client to server
            </summary>
        </member>
        <member name="E:DXHook.Interface.CaptureInterface.ScreenshotReceived">
            <summary>
            Server event for receiving screenshot image data
            </summary>
        </member>
        <member name="E:DXHook.Interface.CaptureInterface.RecordingStarted">
            <summary>
            Client event used to communicate to the client that it is time to start recording
            </summary>
        </member>
        <member name="E:DXHook.Interface.CaptureInterface.RecordingStopped">
            <summary>
            Client event used to communicate to the client that it is time to stop recording
            </summary>
        </member>
        <member name="E:DXHook.Interface.CaptureInterface.ScreenshotRequested">
            <summary>
            Client event used to communicate to the client that it is time to create a screenshot
            </summary>
        </member>
        <member name="E:DXHook.Interface.CaptureInterface.Disconnected">
            <summary>
            Client event used to notify the hook to exit
            </summary>
        </member>
        <member name="E:DXHook.Interface.CaptureInterface.DisplayText">
            <summary>
            Client event used to display a piece of text in-game
            </summary>
        </member>
        <member name="E:DXHook.Interface.CaptureInterface.DrawOverlay">
            <summary>
                Client event used to (re-)draw an overlay in-game.
            </summary>
        </member>
        <member name="M:DXHook.Interface.CaptureInterface.StartRecording(DXHook.Interface.CaptureConfig)">
            <summary>
            If not <see cref="P:DXHook.Interface.CaptureInterface.IsRecording"/> will invoke the <see cref="E:DXHook.Interface.CaptureInterface.RecordingStarted"/> event, starting a new recording. 
            </summary>
            <param name="config">The configuration for the recording</param>
            <remarks>Handlers in the server and remote process will be be invoked.</remarks>
        </member>
        <member name="M:DXHook.Interface.CaptureInterface.StopRecording">
            <summary>
            If <see cref="P:DXHook.Interface.CaptureInterface.IsRecording"/>, will invoke the <see cref="E:DXHook.Interface.CaptureInterface.RecordingStopped"/> event, finalising any existing recording.
            </summary>
            <remarks>Handlers in the server and remote process will be be invoked.</remarks>
        </member>
        <member name="M:DXHook.Interface.CaptureInterface.GetScreenshot">
            <summary>
            Get a fullscreen screenshot with the default timeout of 2 seconds
            </summary>
        </member>
        <member name="M:DXHook.Interface.CaptureInterface.GetScreenshot(System.Drawing.Rectangle,System.TimeSpan,System.Nullable{System.Drawing.Size},DXHook.Interface.ImageFormat)">
            <summary>
            Get a screenshot of the specified region
            </summary>
            <param name="region">the region to capture (x=0,y=0 is top left corner)</param>
            <param name="timeout">maximum time to wait for the screenshot</param>
        </member>
        <member name="M:DXHook.Interface.CaptureInterface.Disconnect">
            <summary>
            Tell the client process to disconnect
            </summary>
        </member>
        <member name="M:DXHook.Interface.CaptureInterface.Message(DXHook.Interface.MessageType,System.String,System.Object[])">
            <summary>
            Send a message to all handlers of <see cref="E:DXHook.Interface.CaptureInterface.RemoteMessage"/>.
            </summary>
            <param name="messageType"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:DXHook.Interface.CaptureInterface.DisplayInGameText(System.String)">
            <summary>
            Display text in-game for the default duration of 5 seconds
            </summary>
            <param name="text"></param>
        </member>
        <member name="M:DXHook.Interface.CaptureInterface.DisplayInGameText(System.String,System.TimeSpan)">
            <summary>
            
            </summary>
            <param name="text"></param>
            <param name="duration"></param>
        </member>
        <member name="M:DXHook.Interface.CaptureInterface.DrawOverlayInGame(DXHook.Hook.Common.IOverlay)">
            <summary>
            Replace the in-game overlay with the one provided.
            
            Note: this is not designed for fast updates (i.e. only a couple of times per second)
            </summary>
            <param name="overlay"></param>
        </member>
        <member name="M:DXHook.Interface.CaptureInterface.Ping">
            <summary>
            Used to confirm connection to IPC server channel
            </summary>
        </member>
        <member name="T:DXHook.Interface.ClientCaptureInterfaceEventProxy">
            <summary>
            Client event proxy for marshalling event handlers
            </summary>
        </member>
        <member name="E:DXHook.Interface.ClientCaptureInterfaceEventProxy.RecordingStarted">
            <summary>
            Client event used to communicate to the client that it is time to start recording
            </summary>
        </member>
        <member name="E:DXHook.Interface.ClientCaptureInterfaceEventProxy.RecordingStopped">
            <summary>
            Client event used to communicate to the client that it is time to stop recording
            </summary>
        </member>
        <member name="E:DXHook.Interface.ClientCaptureInterfaceEventProxy.ScreenshotRequested">
            <summary>
            Client event used to communicate to the client that it is time to create a screenshot
            </summary>
        </member>
        <member name="E:DXHook.Interface.ClientCaptureInterfaceEventProxy.Disconnected">
            <summary>
            Client event used to notify the hook to exit
            </summary>
        </member>
        <member name="E:DXHook.Interface.ClientCaptureInterfaceEventProxy.DisplayText">
            <summary>
            Client event used to display in-game text
            </summary>
        </member>
        <member name="E:DXHook.Interface.ClientCaptureInterfaceEventProxy.DrawOverlay">
            <summary>
                Client event used to (re-)draw an overlay in-game.
            </summary>
        </member>
        <member name="T:DXHook.Interface.DrawOverlayEventArgs">
            <summary>
            Note: Deliberately not using MarshalByRefObj
            </summary>
        </member>
        <member name="M:DXHook.Interface.Screenshot.Disconnect">
            <summary>
            Disconnects the remoting channel(s) of this object and all nested objects.
            </summary>
        </member>
        <member name="M:DXHook.Interface.ScreenshotRequest.Disconnect">
            <summary>
            Disconnects the remoting channel(s) of this object and all nested objects.
            </summary>
        </member>
        <member name="M:DXHook.NativeMethods.ShowWindow(System.IntPtr,DXHook.NativeMethods.WindowShowStyle)">
             <summary>Shows a Window</summary>
             <remarks>
             <para>To perform certain special effects when showing or hiding a
             window, use AnimateWindow.</para>
            <para>The first time an application calls ShowWindow, it should use
            the WinMain function's nCmdShow parameter as its nCmdShow parameter.
            Subsequent calls to ShowWindow must use one of the values in the
            given list, instead of the one specified by the WinMain function's
            nCmdShow parameter.</para>
            <para>As noted in the discussion of the nCmdShow parameter, the
            nCmdShow value is ignored in the first call to ShowWindow if the
            program that launched the application specifies startup information
            in the structure. In this case, ShowWindow uses the information
            specified in the STARTUPINFO structure to show the window. On
            subsequent calls, the application must call ShowWindow with nCmdShow
            set to SW_SHOWDEFAULT to use the startup information provided by the
            program that launched the application. This behavior is designed for
            the following situations: </para>
            <list type="">
                <item>Applications create their main window by calling CreateWindow
                with the WS_VISIBLE flag set. </item>
                <item>Applications create their main window by calling CreateWindow
                with the WS_VISIBLE flag cleared, and later call ShowWindow with the
                SW_SHOW flag set to make it visible.</item>
            </list></remarks>
             <param name="hWnd">Handle to the window.</param>
             <param name="nCmdShow">Specifies how the window is to be shown.
             This parameter is ignored the first time an application calls
             ShowWindow, if the program that launched the application provides a
             STARTUPINFO structure. Otherwise, the first time ShowWindow is called,
             the value should be the value obtained by the WinMain function in its
             nCmdShow parameter. In subsequent calls, this parameter can be one of
             the WindowShowStyle members.</param>
             <returns>
             If the window was previously visible, the return value is nonzero.
             If the window was previously hidden, the return value is zero.
             </returns>
        </member>
        <member name="T:DXHook.NativeMethods.WindowShowStyle">
            <summary>Enumeration of the different ways of showing a window using
            ShowWindow</summary>
        </member>
        <member name="F:DXHook.NativeMethods.WindowShowStyle.Hide">
            <summary>Hides the window and activates another window.</summary>
            <remarks>See SW_HIDE</remarks>
        </member>
        <member name="F:DXHook.NativeMethods.WindowShowStyle.ShowNormal">
            <summary>Activates and displays a window. If the window is minimized
            or maximized, the system restores it to its original size and
            position. An application should specify this flag when displaying
            the window for the first time.</summary>
            <remarks>See SW_SHOWNORMAL</remarks>
        </member>
        <member name="F:DXHook.NativeMethods.WindowShowStyle.ShowMinimized">
            <summary>Activates the window and displays it as a minimized window.</summary>
            <remarks>See SW_SHOWMINIMIZED</remarks>
        </member>
        <member name="F:DXHook.NativeMethods.WindowShowStyle.ShowMaximized">
            <summary>Activates the window and displays it as a maximized window.</summary>
            <remarks>See SW_SHOWMAXIMIZED</remarks>
        </member>
        <member name="F:DXHook.NativeMethods.WindowShowStyle.Maximize">
            <summary>Maximizes the specified window.</summary>
            <remarks>See SW_MAXIMIZE</remarks>
        </member>
        <member name="F:DXHook.NativeMethods.WindowShowStyle.ShowNormalNoActivate">
            <summary>Displays a window in its most recent size and position.
            This value is similar to "ShowNormal", except the window is not
            actived.</summary>
            <remarks>See SW_SHOWNOACTIVATE</remarks>
        </member>
        <member name="F:DXHook.NativeMethods.WindowShowStyle.Show">
            <summary>Activates the window and displays it in its current size
            and position.</summary>
            <remarks>See SW_SHOW</remarks>
        </member>
        <member name="F:DXHook.NativeMethods.WindowShowStyle.Minimize">
            <summary>Minimizes the specified window and activates the next
            top-level window in the Z order.</summary>
            <remarks>See SW_MINIMIZE</remarks>
        </member>
        <member name="F:DXHook.NativeMethods.WindowShowStyle.ShowMinNoActivate">
            <summary>Displays the window as a minimized window. This value is
            similar to "ShowMinimized", except the window is not activated.</summary>
            <remarks>See SW_SHOWMINNOACTIVE</remarks>
        </member>
        <member name="F:DXHook.NativeMethods.WindowShowStyle.ShowNoActivate">
            <summary>Displays the window in its current size and position. This
            value is similar to "Show", except the window is not activated.</summary>
            <remarks>See SW_SHOWNA</remarks>
        </member>
        <member name="F:DXHook.NativeMethods.WindowShowStyle.Restore">
            <summary>Activates and displays the window. If the window is
            minimized or maximized, the system restores it to its original size
            and position. An application should specify this flag when restoring
            a minimized window.</summary>
            <remarks>See SW_RESTORE</remarks>
        </member>
        <member name="F:DXHook.NativeMethods.WindowShowStyle.ShowDefault">
            <summary>Sets the show state based on the SW_ value specified in the
            STARTUPINFO structure passed to the CreateProcess function by the
            program that started the application.</summary>
            <remarks>See SW_SHOWDEFAULT</remarks>
        </member>
        <member name="F:DXHook.NativeMethods.WindowShowStyle.ForceMinimized">
            <summary>Windows 2000/XP: Minimizes a window, even if the thread
            that owns the window is hung. This flag should only be used when
            minimizing windows from a different thread.</summary>
            <remarks>See SW_FORCEMINIMIZE</remarks>
        </member>
        <member name="M:DXHook.NativeMethods.GetForegroundWindow">
            <summary>
            The GetForegroundWindow function returns a handle to the foreground window.
            </summary>
        </member>
        <member name="T:SharpDX.Component">
            <summary>
            A disposable component base class.
            </summary>
        </member>
        <member name="P:SharpDX.Component.DisposeCollector">
            <summary>
            Gets or sets the disposables.
            </summary>
            <value>The disposables.</value>
        </member>
        <member name="M:SharpDX.Component.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Component"/> class.
            </summary>
        </member>
        <member name="M:SharpDX.Component.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.Component" /> class with an immutable name.
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="P:SharpDX.Component.IsAttached">
            <summary>
            Gets or sets a value indicating whether this instance is attached to a collector.
            </summary>
            <value>
            	<c>true</c> if this instance is attached to a collector; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:SharpDX.Component.IsDisposed">
            <summary>
            Gets a value indicating whether this instance is disposed.
            </summary>
            <value>
            	<c>true</c> if this instance is disposed; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="E:SharpDX.Component.Disposing">
            <summary>
            Occurs when when Dispose is called.
            </summary>
        </member>
        <member name="M:SharpDX.Component.Dispose">
            <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
        </member>
        <member name="M:SharpDX.Component.Dispose(System.Boolean)">
            <summary>
            Disposes of object resources.
            </summary>
            <param name="disposeManagedResources">If true, managed resources should be
            disposed of in addition to unmanaged resources.</param>
        </member>
        <member name="M:SharpDX.Component.ToDispose``1(``0)">
            <summary>
            Adds a disposable object to the list of the objects to dispose.
            </summary>
            <param name="toDisposeArg">To dispose.</param>
        </member>
        <member name="M:SharpDX.Component.RemoveAndDispose``1(``0@)">
            <summary>
            Dispose a disposable object and set the reference to null. Removes this object from the ToDispose list.
            </summary>
            <param name="objectToDispose">Object to dispose.</param>
        </member>
        <member name="M:SharpDX.Component.RemoveToDispose``1(``0)">
            <summary>
            Removes a disposable object to the list of the objects to dispose.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="toDisposeArg">To dispose.</param>
        </member>
        <member name="T:SharpDX.ComponentBase">
            <summary>
            A lightweight Component base class.
            </summary>
        </member>
        <member name="F:SharpDX.ComponentBase.name">
            <summary>
            Occurs while this component is disposing and before it is disposed.
            </summary>
        </member>
        <member name="F:SharpDX.ComponentBase.isNameImmutable">
            <summary>
            Gets or sets a value indicating whether the name of this instance is immutable.
            </summary>
            <value><c>true</c> if this instance is name immutable; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:SharpDX.ComponentBase.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.ComponentBase" /> class with a mutable name.
            </summary>
        </member>
        <member name="M:SharpDX.ComponentBase.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:SharpDX.ComponentBase" /> class with an immutable name.
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="P:SharpDX.ComponentBase.Name">
            <summary>
            Gets the name of this component.
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:SharpDX.ComponentBase.Tag">
            <summary>
            Gets or sets the tag associated to this object.
            </summary>
            <value>The tag.</value>
        </member>
        <member name="E:SharpDX.ComponentBase.PropertyChanged">
            <summary>
            Occurs when a property value changes.
            </summary>
        </member>
        <member name="T:SharpDX.IComponent">
            <summary>
            Base interface for a component base.
            </summary>
        </member>
        <member name="P:SharpDX.IComponent.Name">
            <summary>
            Gets the name of this component.
            </summary>
            <value>The name.</value>
        </member>
    </members>
</doc>
